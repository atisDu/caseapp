import React, { useState, useEffect } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './components/ui/tabs';
import { Design } from './types/design';
import { Order } from './types/order';
import { supabase } from './utils/supabase/client';

export interface User {
  id: string;
  email: string;
  name: string;
}

const App = () => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [designs, setDesigns] = useState<Design[]>([]);
  const [orders, setOrders] = useState<Order[]>([]);

  import React, { useState, useEffect } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from './components/ui/tabs';
import { Badge } from './components/ui/badge';
import { DesignStudio } from './components/DesignStudio';
import { OrderHistory } from './components/OrderHistory';
import { UserProfile } from './components/UserProfile';
import { CompanyDashboard } from './components/CompanyDashboard';
import { Header } from './components/Header';
import { AuthForm } from './components/AuthForm';
import { ShoppingCart, User as UserIcon, Palette, Building } from 'lucide-react';
import { Language, t } from './utils/translations';
import { supabase } from './utils/supabase/client';
import { Design } from './types/design';
import { Order } from './types/order';

export interface User {
  id: string;
  name: string;
  email: string;
  isAdmin: boolean;
}

export default function App() {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [designs, setDesigns] = useState<Design[]>([]);
  const [orders, setOrders] = useState<Order[]>([]);
  const [activeTab, setActiveTab] = useState('design');
  const [language, setLanguage] = useState<Language>('en');
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeApp = async () => {
      try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
          console.error('Session check error:', error.message);
        } else if (session?.user) {
          setCurrentUser({
            id: session.user.id,
            name: session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',
            email: session.user.email || '',
            isAdmin: session.user.user_metadata?.isAdmin || false
          });
        }
      } catch (error: any) {
        console.error('Session initialization error:', error.message);
      }

      setIsLoading(false);
    };

    initializeApp();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (session?.user) {
        setCurrentUser({
          id: session.user.id,
          name: session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',
          email: session.user.email || '',
          isAdmin: session.user.user_metadata?.isAdmin || false
        });
      } else {
        setCurrentUser(null);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  useEffect(() => {
    const loadUserData = async () => {
      if (!currentUser) return;
      
      const [designsResponse, ordersResponse] = await Promise.all([
        supabase.from('designs').select('*').eq('user_id', currentUser.id),
        supabase.from('orders').select('*, design:designs(*)').eq('user_id', currentUser.id)
      ]);

      if (designsResponse.error) {
        console.error('Error loading designs:', designsResponse.error);
      } else {
        setDesigns(designsResponse.data || []);
      }

      if (ordersResponse.error) {
        console.error('Error loading orders:', ordersResponse.error);
      } else {
        setOrders(ordersResponse.data || []);
      }
    };

    loadUserData();
  }, [currentUser]);

  const updateDesign = async (designId: string, updates: Partial<Design>) => {
    try {
      const { error } = await supabase
        .from('designs')
        .update(updates)
        .eq('id', designId);

      if (error) throw error;
      setDesigns(prev => prev.map(d => d.id === designId ? { ...d, ...updates } : d));
    } catch (error) {
      console.error('Error updating design:', error);
    }
  };

  const deleteDesign = async (designId: string) => {
    try {
      const { error } = await supabase
        .from('designs')
        .delete()
        .eq('id', designId);

      if (error) throw error;
      setDesigns(prev => prev.filter(d => d.id !== designId));
    } catch (error) {
      console.error('Error deleting design:', error);
    }
  };

  const addOrder = async (orderData: Omit<Order, 'id' | 'status'>) => {
    if (!currentUser) return;

    try {
      const { data: order, error } = await supabase
        .from('orders')
        .insert([{
          user_id: currentUser.id,
          design_id: orderData.design.id,
          quantity: orderData.quantity,
          phone_model: orderData.phoneModel,
          total_price: orderData.totalPrice,
          status: 'pending',
          customer_info: orderData.customerInfo
        }])
        .select()
        .single();

      if (error) throw error;
      setOrders(prev => [...prev, order]);
      return order;
    } catch (error) {
      console.error('Error creating order:', error);
      throw error;
    }
  };

  const updateOrderStatus = async (orderId: string, status: 'pending' | 'processing' | 'shipped' | 'delivered') => {
    try {
      const { error } = await supabase
        .from('orders')
        .update({ status })
        .eq('id', orderId);

      if (error) throw error;
      setOrders(prev => prev.map(o => o.id === orderId ? { ...o, status } : o));
    } catch (error) {
      console.error('Error updating order status:', error);
    }
  };if (!currentUser) return;
    
    const { data: design, error } = await supabase
      .from('designs')
      .insert([{ ...designData, user_id: currentUser.id }])
      .select()
      .single();

    if (error) {
      console.error('Error creating design:', error);
      return;
    }

    setDesigns(prev => [...prev, design]);
  };

  const updateDesign = async (designId: string, updates: Partial<Design>) => {
    const { error } = await supabase
      .from('designs')
      .update(updates)
      .eq('id', designId);

    if (error) {
      console.error('Error updating design:', error);
      return;
    }

    setDesigns(prev => prev.map(d => d.id === designId ? { ...d, ...updates } : d));
  };

  const deleteDesign = async (designId: string) => {
    const { error } = await supabase
      .from('designs')
      .delete()
      .eq('id', designId);

    if (error) {
      console.error('Error deleting design:', error);
      return;
    }

    setDesigns(prev => prev.filter(d => d.id !== designId));
  };

  const addOrder = async (orderData: Omit<Order, 'id' | 'created_at' | 'updated_at'>) => {
    if (!currentUser) return;

    const { data: order, error } = await supabase
      .from('orders')
      .insert([{ 
        ...orderData,
        user_id: currentUser.id,
        status: 'pending',
        design_id: orderData.design.id // Make sure to include design_id
      }])
      .select()
      .single();

    if (error) {
      console.error('Error creating order:', error);
      return;
    }

    setOrders(prev => [...prev, order]);
  };

  const updateOrderStatus = async (orderId: string, status: 'pending' | 'processing' | 'shipped' | 'delivered') => {
    const { error } = await supabase
      .from('orders')
      .update({ status })
      .eq('id', orderId);

    if (error) {
      console.error('Error updating order status:', error);
      return;
    }

    setOrders(prev => prev.map(o => o.id === orderId ? { ...o, status } : o));
  };mponents/ui/button';
import { Badge } from './components/ui/badge';
import { DesignStudio } from './components/DesignStudio';
import { OrderHistory } from './components/OrderHistory';
import { UserProfile } from './components/UserProfile';
import { CompanyDashboard } from './components/CompanyDashboard';
import { Header } from './components/Header';
import { AuthForm } from './components/AuthForm';
import { ShoppingCart, User, Palette, Building } from 'lucide-react';
import { Language, t } from './utils/translations';
import { supabase } from './utils/supabase/client';


export interface Design {
  id: string;
  user_id: string;
  name: string;
  image_url: string;
  phone_model: string;
  material: string;
  created_at?: string;
  updated_at?: string;
  material: string;
  preview?: string;
  createdAt: Date;
}

export interface Order {
  id: string;
  designId: string;
  design: Design;
  quantity: number;
  phoneModel: string;
  totalPrice: number;
  status: 'pending' | 'processing' | 'shipped' | 'delivered';
  customerInfo: {
    name: string;
    email: string;
    address: string;
  };
  createdAt: Date;
}

export interface User {
  id: string;
  name: string;
  email: string;
  isAdmin: boolean;
}

export default function App() {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [designs, setDesigns] = useState<Design[]>([]);
  const [orders, setOrders] = useState<Order[]>([]);
  const [activeTab, setActiveTab] = useState('design');
  const [language, setLanguage] = useState<Language>('lv'); // Latvian as default
  const [isLoading, setIsLoading] = useState(true);
  

  // Check for existing session and load data on component mount
  useEffect(() => {
    const initializeApp = async () => {
      try {
        // Check for existing Supabase session
        console.log('Checking for existing session...');
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
          console.log('Session check error:', error.message);
        } else if (session?.user) {
          console.log('Found existing session for user:', session.user.id);
          setCurrentUser({
            id: session.user.id,
            name: session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',
            email: session.user.email || '',
            isAdmin: session.user.user_metadata?.isAdmin || false
          });
        } else {
          console.log('No existing session found');
        }
      } catch (error: any) {
        console.log('Session initialization error:', error.message);
      }

      setIsLoading(false);
    };

    initializeApp();

    // Listen to auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      console.log('Auth state changed:', event, session?.user?.id);
      if (session?.user) {
        setCurrentUser({
          id: session.user.id,
          name: session.user.user_metadata?.name || session.user.email?.split('@')[0] || 'User',
          email: session.user.email || '',
          isAdmin: session.user.user_metadata?.isAdmin || false
        });
      } else {
        setCurrentUser(null);
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  // Set up initial design and order data loading from Supabase when user changes
  useEffect(() => {
    const loadUserData = async () => {
      if (currentUser) {
        // Load designs
        const { data: designData, error: designError } = await supabase
          .from('designs')
          .select('*')
          .eq('user_id', currentUser.id);

        if (designError) {
          console.error('Error loading designs:', designError);
        } else {
          setDesigns(designData || []);
        }

        // Load orders
        const { data: orderData, error: orderError } = await supabase
          .from('orders')
          .select('*, designs(*)')
          .eq('user_id', currentUser.id);

        if (orderError) {
          console.error('Error loading orders:', orderError);
        } else {
          setOrders(orderData || []);
        }
      }
    };

    loadUserData();
  }, [currentUser]);

  const addDesign = (design: Design) => {
    setDesigns(prev => [...prev, design]);
  };

  const updateDesign = (designId: string, updates: Partial<Design>) => {
    setDesigns(prev => prev.map(d => d.id === designId ? { ...d, ...updates } : d));
  };

  const deleteDesign = (designId: string) => {
    setDesigns(prev => prev.filter(d => d.id !== designId));
  };

  const addOrder = (order: Order) => {
    setOrders(prev => [...prev, order]);
  };

  const updateOrderStatus = (orderId: string, status: Order['status']) => {
    setOrders(prev => prev.map(o => o.id === orderId ? { ...o, status } : o));
  };

  const toggleLanguage = () => {
    setLanguage(prev => prev === 'lv' ? 'en' : 'lv');
  };

  const handleAuth = (user: User) => {
    setCurrentUser(user);
  };

  const handleLogout = async () => {
    try {
      console.log('Signing out user...');
      const { error } = await supabase.auth.signOut();
      if (error) {
        console.log('Sign out error:', error.message);
      } else {
        console.log('User signed out successfully');
      }
    } catch (error: any) {
      console.log('Sign out exception:', error.message);
    }
    setCurrentUser(null);
    setActiveTab('design');
  };

  // Show loading spinner while checking session
  if (isLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary"></div>
      </div>
    );
  }

  // Show login form if user is not authenticated
  if (!currentUser) {
    return <AuthForm onAuth={handleAuth} language={language} />;
  }


  return (
    
    <div className="min-h-screen bg-background">
      <Header 
        user={currentUser} 
        onLogout={handleLogout}
        language={language}
        onToggleLanguage={toggleLanguage}
      />
      
      <div className="container mx-auto p-3 sm:p-6">
        <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
          <TabsList className={`grid w-full ${currentUser.isAdmin ? 'grid-cols-4' : 'grid-cols-3'}`}>
            <TabsTrigger value="design" className="flex items-center gap-1 sm:gap-2">
              <Palette className="w-4 h-4" />
              <span className="hidden sm:inline">{t(language, 'designStudio')}</span>
              <span className="sm:hidden">{t(language, 'design')}</span>
            </TabsTrigger>
            <TabsTrigger value="orders" className="flex items-center gap-1 sm:gap-2">
              <ShoppingCart className="w-4 h-4" />
              <span className="hidden sm:inline">{t(language, 'orders')}</span>
              <span className="sm:hidden">{t(language, 'orders')}</span>
              {orders.length > 0 && (
                <Badge variant="secondary" className="ml-1 text-xs">
                  {orders.length}
                </Badge>
              )}
            </TabsTrigger>
            <TabsTrigger value="profile" className="flex items-center gap-1 sm:gap-2">
              <User className="w-4 h-4" />
              <span className="hidden sm:inline">{t(language, 'profile')}</span>
              <span className="sm:hidden">{t(language, 'profile')}</span>
            </TabsTrigger>
            {currentUser.isAdmin && (
              <TabsTrigger value="company" className="flex items-center gap-1 sm:gap-2">
                <Building className="w-4 h-4" />
                <span className="hidden sm:inline">{t(language, 'company')}</span>
                <span className="sm:hidden">{t(language, 'company')}</span>
              </TabsTrigger>
            )}
          </TabsList>

          <TabsContent value="design" className="mt-6">
            <DesignStudio 
              designs={designs}
              onAddDesign={addDesign}
              onUpdateDesign={updateDesign}
              onDeleteDesign={deleteDesign}
              onCreateOrder={addOrder}
              currentUser={currentUser}
              language={language}
            />
          </TabsContent>

          <TabsContent value="orders" className="mt-6">
            <OrderHistory 
              orders={orders.filter(o => !currentUser.isAdmin)}
              onUpdateOrder={updateOrderStatus}
              language={language}
            />
          </TabsContent>

          <TabsContent value="profile" className="mt-6">
            <UserProfile 
              user={currentUser}
              onUpdateUser={setCurrentUser}
              designs={designs}
              orders={orders.filter(o => !currentUser.isAdmin)}
              language={language}
            />
          </TabsContent>

          {currentUser.isAdmin && (
            <TabsContent value="company" className="mt-6">
              <CompanyDashboard 
                orders={orders}
                onUpdateOrderStatus={updateOrderStatus}
                designs={designs}
                language={language}
              />
            </TabsContent>
          )}
        </Tabs>
        
        
        
      </div>
    </div>
    
  );

  
}